//如果子类和父类的变量名一样，那么优先访问子类
//如果子类有并且可以访问那么就直接返回子类的该属性
//子类没有就去其父类查找该属性,如果父类有且可以访问那么就返回父类的该属性
//其父类没有就去访问其父类的父类，然后遵循上述规则，一直到Object类
//子类构造器里有this(),就会屏蔽掉其自带的super()

//方法重写中，子类的方法返回类型要和父类一样，或者是父类的子类
//子类的重写方法不能缩小父类方法的访问权限
//方法重载对返回的类型没有要求,且对修饰符也没有要求

//多态的向上转型
//一个对象的编译类型和运行类型可以不一样
//编译类型在定义对象的时候就决定了，而运行对象可以改变
//等号的左边是编译类型，右边是运行类型
// Animal animal = new Dog();
// animal = new Cat();
//访问属性的时候看的时编译的类型
//多态的向下转型
//子类类型 引用名 = （子类类型）父类引用
//可以使用子类的特有方法
//要求父类的引用要指向当前目标类型的对象
//Animal animal = new Dog();
//因为现在animal这个父类的引用指向Dog
//所以才能向下转型指向Dog
//Dog dog = (dog) animal;
//所有只有向上转型后才能向下转型
//动态绑定机制
//当调用对象方法的时候，该方法会和运行类型绑定
//属性没有动态绑定机制，那里声明就使用那里